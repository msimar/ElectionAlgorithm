package com.mps.pearl.core;

import java.util.Timer;
import java.util.TimerTask;

import com.mps.pearl.util.Constant;
import com.mps.pearl.util.Logger;

/**
 * 
 * This class implements Node running in a System. The Nodes can be 
 * either a Server or a Client Node. Client or Server are the trait 
 * organized in a single Node. 
 * 
 * Server Node act as Coordinator for the System and respond to the 
 * queries generated by the clients.
 * 
 * Client Node act as Other Nodes in the System and ping Server Node
 * to check the state of the Server. At any moment, if the Client Node
 * observed that Server Node is down, the Client Node will initiate 
 * Election process and send message to other active Nodes in a System. 
 * If the index of the Other Node is greater than the Node who initiated 
 * the Election, the Node with higher index will bully the current Election process.
 * The Node with higher index will begin the Election process. 
 * 
 * This process of Election continue until message to all the Nodes in a 
 * system has been received and processed. At the end, the node with highest
 * index will be declared as new Server Node or Coordinator for the System.
 * 
 * @author msingh
 * @version 1.0 20 Jan, 2014
 *
 */

public class Node extends TraitClientServer implements Comparable<Node> {

	/**
	 * A Logger tag
	 */
	private final String TAG = Node.class.getSimpleName();
	
	/**
	 * A unique id for the Node
	 */
	private int id;
	
	/**
	 * Boolean flag to identify state 
	 */
	private boolean downFlag;
	
	/**
	 * Boolean flag to check if Node is Coordinator or Other Node 
	 */
	private boolean coordinatorFlag;
	
	/**
	 * A Client Timer to Schedule Tasks 
	 */
	private Timer mClientTimer;
	
	/**
	 * A Server Timer to Schedule Tasks 
	 */
	private Timer mServerTimer;
	
	/**
	 * Creates an Node object.
	 * @param id the Unique Id bound to the Node
	 * @param ipAddress the IP Address bound to the Node
	 * @param port the Port Address bound to the Node
	 */
	public Node(int id, String ipAddress, String port) {
		setId(id);
		setIPAddress(ipAddress);
		setPort(port);
		setCoordinatorFlag(false);
		setDownFlag(false);
		
		this.mClientTimer = new Timer();
		this.mServerTimer = new Timer();
	}

	/**
	 * Returns the ID of the Node
	 * @return the integer Id of the Node
	 */
	public int getId() {
		return id;
	}

	/**
	 * Set an ID of the Node
	 * @param id the integer Id of the Node
	 */
	public void setId(int id) {
		this.id = id;
	}

	/**
	 * Returns the String representation of the Node
	 */
	@Override
	public String toString() {
		// TODO Auto-generated method stub
		return "[" + id + "]" + IPAddress + ":" + port;
	}

	/**
	 * Returns the integer difference of Compared Nodes 
	 */
	@Override
	public int compareTo(Node node) {
		// TODO Auto-generated method stub
		 return node.id - this.id;
	}

	/**
	 * Returns True if the Node is Down, False if the Node is 
	 * active in a System
	 *  
	 * @return True if the Node is Down, False if the Node is Active
	 */
	public boolean isDownFlag() {
		return downFlag;
	}

	/**
	 * Set True if the Node is Down, False if the Node is 
	 * active in a System 
	 * 
	 * @param downFlag the Node state flag ( Active / Down )
	 */
	public void setDownFlag(boolean downFlag) {
		this.downFlag = downFlag;
	}

	/**
	 * Returns the Node state as Coordinator of the System 
	 * @return True, if the Node is selected as New Coordinator, False, if the Node act as Other Nodes.
	 */
	public boolean isCoordinatorFlag() {
		return coordinatorFlag;
	}

	/**
	 * Set the Node state as Coordinator of the System 
	 * @param coordinatorFlag True, if the Node is selected as New Coordinator, False, if the Node act as Other Nodes.
	 */
	public void setCoordinatorFlag(boolean coordinatorFlag) {
		if(Logger.DEBUG)Logger.d(TAG, "setCoordinatorFlag()");
		this.coordinatorFlag = coordinatorFlag;
		if( coordinatorFlag && (mClientTimer != null) ){
			// cancel all timer if the Node is selected as a New Coordinator :: SERVER NODE
			mClientTimer.cancel();
		}
	}

	/**
	 ************ CLIENT CONFIGURATION ***********  
	 */

	/**
	 * This method perform ping coordination between Client and Server Nodes.
	 */
	public void pingCoordinator() {
		if(Logger.DEBUG)Logger.d(TAG, " ------ pingCoordinator()  ------ : " + this);
		// ping server node every 5 seconds 
		mClientTimer.scheduleAtFixedRate(new PingSchedularTask(), 0 , Constant.CLIENT_PING_EVERY_SECONDS*1000);
	}
	
	/**
	 * This class implements TimerTask which schedule Ping 
	 * action on a regular interval to Server Node.
	 * 
	 * The client Node will perform ping if the Server is Active, 
	 * otherwise, perform Election if the Server Node is Down in a 
	 * System.
	 * 
	 * @author msingh
	 * @version 1.0 20 Jan, 2014 
	 */
	class PingSchedularTask extends TimerTask {
	   	
		/**
		 * This method perform ping or election routines. 
		 */
		public void run() {
			if(Logger.DEBUG)Logger.d(TAG, " ------ PingSchedularTask.run() ------ ");
			// get server name 
			Node serverNode  = NodeManager.getInstance().getServerNode();
			// HostName as Null indicates ServerNode went Down
			if( serverNode == null ){
				// process Election
				try {
					
					if( !Election.getInstance().isElectionFlag()){
						// begin new election 
						Election.getInstance().beginElection();
					}
					
					synchronized(Election.lock){
						// critical section to perform election
//						Election.lock.wait();
						performCoordinatorElection();
//						Election.lock.notifyAll();
					}
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}else if( serverNode != null ){
				pingServerNode();
			}
        }
    }
	
	/**
	 * This method perform Election to find new Coordinator or Server
	 * Node in a System.
	 */
	private synchronized void performCoordinatorElection() {
		if(Logger.DEBUG)Logger.d(TAG, "performCoordinatorElection() : isElectionFlag : " + Election.getInstance().isElectionFlag());
		
		if(this.isCoordinatorFlag()) return;
		
		if( Election.getInstance().getElectionNodeList().size() >= 0 ){
			if(Election.getInstance().isValidElection(this.getId())){
				// add node to the election list
				if(Election.getInstance().getElectionNodeList().get(getId()) == null){
					Election.getInstance().addElectionNode(this);
				}
				
				System.out.println(Election.getInstance().getElectionMessage());
				
				if(Logger.DEBUG)Logger.d(TAG, "performCoordinatorElection() :XX:" + Election.getInstance().getElectionMessage());
				if(Logger.DEBUG)Logger.d(TAG, " :: " + Resource.getInstance().getNodeList().size() + " == " + Election.getInstance().getElectionNodeList().size() );
				
				// if the Node is a last node, then end the Election
				if(Resource.getInstance().getNodeList().size() == Election.getInstance().getElectionNodeList().size()){
					// proceed to end the Election
					NodeManager.getInstance().setServerNode(Election.getInstance().endElection());
					// set the coordinator Flag for the Node
		    		NodeManager.getInstance().getServerNode().setCoordinatorFlag(true);
		    		// set the flag as Server Node started Listening on his port
		    		NodeManager.getInstance().getServerNode().setServerListening(true);
					// bind server node
		    		NodeManager.getInstance().bindServerNode();
				}
			}else{ // New TraitClientServer Node with Highest Index has been Found 
				// abort existing election
				Election.getInstance().abortElection();
				// begin new election 
				Election.getInstance().beginElection();
				Election.getInstance().addElectionNode(this);
				
				System.out.println(Election.getInstance().getElectionMessage());
				
				if(Logger.DEBUG)Logger.d(TAG, "performCoordinatorElection() :XX:" + Election.getInstance().getElectionMessage());
			}
		} 
	}
	
	/*
	 ************ SERVER CONFIGURATION ***********  
	 */
	
	/**
	 * This method terminate Server Node after timer interval 
	 * mention in a Abort  Scheduler Timer Task.  
	 */
	public void terminateNode(){
		if(Logger.DEBUG)Logger.d(TAG, " ############ terminateNode() : " + this + " ############  ");
		// schedule timer to abort server every 10 seconds 
		mServerTimer.schedule(new AbortCoordinatorTask(this), Constant.SERVER_ABORT_EVERY_SECONDS*1000);
	} 

	/**
	 * This class implements TimerTask to perform schedule abort of 
	 * coordinator running in a System. It abort the currently running 
	 * Server Node in a System. After termination, if provide an option
	 * to perform Election to elect new Coordinator for the System.
	 * 
	 * @author msingh
	 * @version 1.0 20 Jan, 2014 
	 *
	 */
	class AbortCoordinatorTask extends TimerTask {
    	
		/**
		 * A Node instance to terminate
		 */
		private Node node;
		
		/**
		 * Creates an AbortCoordinatorTask object.
		 * 
		 * @param node the Node instance to terminate 
		 */
		public AbortCoordinatorTask(Node node){
			this.node = node;
		}
		
		/**
		 * This methods perform termination of Currently running 
		 * Node as a Coordinator in the System.
		 */
        public void run() {
        	if(Logger.DEBUG)Logger.d(TAG, " ############ AbortCoordinatorTask.run()  ############ ");
        	
        	System.out.println("t " + node.getId() );
            
        	// update the coordinator state
    		setCoordinatorFlag(false);
    		setDownFlag(true);
    		
    		// terminate all the threads bind to the server node
    		for(Thread multiClientHandlerThread : getServerSocketThreadList())
    			multiClientHandlerThread.interrupt();
    		
    		// add the Node to the terminator List
    		Resource.getInstance().addTerminatedNode(node);
    		
    		// set the coordinator Flag for the Node
    		NodeManager.getInstance().getServerNode().setCoordinatorFlag(false);
    		
    		NodeManager.getInstance().getServerNode().setServerListening(false);
    		
    		// set server node as NULL
    		NodeManager.getInstance().setServerNode(null);
    		
            mServerTimer.cancel(); //Terminate the timer thread
        }
    }
}
